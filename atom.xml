<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ebeo-yvnjiang.github.io</id>
    <title>Billy2007&amp;GoneTimeの世界</title>
    <updated>2020-08-17T10:27:04.741Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ebeo-yvnjiang.github.io"/>
    <link rel="self" href="https://ebeo-yvnjiang.github.io/atom.xml"/>
    <subtitle>萧索，飘摇。</subtitle>
    <logo>https://ebeo-yvnjiang.github.io/images/avatar.png</logo>
    <icon>https://ebeo-yvnjiang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Billy2007&amp;GoneTimeの世界</rights>
    <entry>
        <title type="html"><![CDATA[从历年NOIP普及~提高-难度的题学调试方法]]></title>
        <id>https://ebeo-yvnjiang.github.io/post/tiao-shi-fang-fa/</id>
        <link href="https://ebeo-yvnjiang.github.io/post/tiao-shi-fang-fa/">
        </link>
        <updated>2020-08-17T02:28:03.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>Luogu1076 寻宝
<ul>
<li>代码思路</li>
</ul>
</li>
</ol>
<p>纯模拟。但是需要通过模运算优化掉不需要的环。</p>
<ul>
<li>调试部分</li>
</ul>
<p>因为题目中有<strong>如果当前房间本身就有楼梯通向上层，该房间作为第一个有楼梯的房间</strong>这句话，所以如果这层有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span>个有楼梯的房间，你第一个看到的房间的牌号是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span>，那么你也要走<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span>步，而不是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>步。</p>
<p>所以，取模的代码要写成<code>a[i][j].num=(a[i][j].num-1)%ct[i]+1</code>，这样的话<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span>的话输出还是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span>。</p>
<ol start="2">
<li>Luogu1077 摆花</li>
</ol>
<ul>
<li>代码思路</li>
</ul>
<p>DP。</p>
<ul>
<li>方程推法</li>
</ul>
<p>题目有两个限制——每一种花能摆多少盆，一共能摆<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>盆。</p>
<p>那么我们可以假设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>为摆完第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>种花有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>盆。</p>
<p>然后呢，不难想出既然花要一种一种摆，那么我们可以枚举每种花摆多少盆。</p>
<p>那么的话，转移方程就很好推了。</p>
<p>具体看代码。</p>
<ol start="3">
<li>Luogu1158 导弹拦截</li>
</ol>
<ul>
<li>代码思路</li>
</ul>
<p>使用<code>struct</code>存每个导弹的数据，再将每个导弹到导弹拦截点的距离算出来，最后再排序后枚举哪些导弹可以给二号系统拦截。</p>
<p>其余的全给一号系统。</p>
<ol start="4">
<li>Luogu1199 三国游戏</li>
</ol>
<ul>
<li>
<p>贪心策略</p>
<p>不难发现贪心测略和电脑的一样即可。</p>
<p>但是要记住读入时<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>×</mo><mo>(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(1,n-1)\times(i+1,n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>的时间复杂度会超时。</p>
</li>
</ul>
<ol start="5">
<li>Luogu1309 瑞士轮</li>
</ol>
<ul>
<li>代码思路</li>
</ul>
<p>模拟+合并。但需要注意的是<code>win</code>和<code>lose</code>要分开排序，要不然会被卡常数。</p>
<ul>
<li>调试策略</li>
</ul>
<p>在看到自己的代码多次被卡的时候可以考虑把快速排序换成归并排序。</p>
<ol start="6">
<li>Luogu2058 海港</li>
</ol>
<ul>
<li>代码思路</li>
</ul>
<p>纯模拟。</p>
<ul>
<li>优化</li>
</ul>
<p>纯暴力显然过不了。所以我们可以把每个人使用一个结构体存起来——这个人来的时间以及这个人的国籍。</p>
<p>每一艘船到达时，我们需要将<code>(这艘船到达的时间t,这艘船上第i个人的国籍x)</code>存入队列，然后<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><msub><mi>s</mi><mi>x</mi></msub><mo>+</mo><mo>+</mo></mrow><annotation encoding="application/x-tex">ans_x++</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">+</span></span></span></span>。</p>
<p>很显然如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><msub><mi>s</mi><mi>x</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">ans_x=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，说明这是一个新的国家，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>+</mo><mo>+</mo></mrow><annotation encoding="application/x-tex">sum++</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">+</span></span></span></span>。</p>
<p>然后从队头开始遍历，将距离当前时间大于一天的船上的人<strong>全部弹出</strong>。</p>
<p>如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><msub><mi>s</mi><mtext>弹出的人的国籍</mtext></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">ans_{\text{弹出的人的国籍}}=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord cjk_fallback mtight">弹出的人的国籍</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>−</mo><mo>−</mo></mrow><annotation encoding="application/x-tex">sum--</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">−</span></span></span></span>。每次询问后输出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span></span></span></span>即可。</p>
<ol start="7">
<li>Luogu2239 螺旋矩阵</li>
</ol>
<ul>
<li>思路</li>
</ul>
<p>这题思路不好想。</p>
<p><strong>画出矩阵、观察规律、推导公式。</strong> 这是解决矩阵类问题似乎一个不错的解。</p>
<p>我们可以得出：</p>
<p>如果是第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 行，那么第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 列的数字就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>；</p>
<p>如果是第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 列，那么第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 行的数字就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>+</mo><mi>i</mi><mi mathvariant="normal">−</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">n+i−1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mord">−</span><span class="mord">1</span></span></span></span>；</p>
<p>如果是第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 行，那么第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 列的数字就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mo>×</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo>−</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo>=</mo><mi>n</mi><mo>×</mo><mn>3</mn><mo>−</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">3 \times n-2-j+1=n\times 3-j-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>；</p>
<p>如果是第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 列，那么第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 行的数字就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn><mo>×</mo><mi>n</mi><mo>−</mo><mn>4</mn><mo>−</mo><mi>i</mi><mo>+</mo><mn>2</mn><mo>=</mo><mi>n</mi><mo>×</mo><mn>4</mn><mo>−</mo><mi>i</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">4 \times n-4-i+2=n\times 4-i-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>。</p>
<p>然后可以递归求解，把螺旋矩阵一层一层地剖开，看看目标位置在哪一层，然后加上这一层最左上角的数字（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn><mo>×</mo><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">4 \times (n - 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>），即为要求的数字。</p>
<p>感谢洛谷用户Anguei的题解。</p>
<ol start="8">
<li>Luogu3956 棋盘</li>
</ol>
<ul>
<li>代码思路</li>
</ul>
<p>记忆化DFS可解。</p>
<ul>
<li>记忆化的方法</li>
</ul>
<p>我们设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f_{i,j}=(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>的最优解。当程序开始时，我们需要将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span>初始化成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord">∞</span></span></span></span>。对于每一次到达的点，如果当前点已经大于目前的最优解，直接<code>return</code>。</p>
<p>否则再继续<code>dfs</code>下去。</p>
<p>剩下的就是普通的<code>dfs</code>了。</p>
<ol start="9">
<li>Luogu5662 纪念品</li>
</ol>
<ul>
<li>代码思路</li>
</ul>
<p>DP。</p>
<ul>
<li>方程推法</li>
</ul>
<p>显然当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">t=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的时候，你就算今天怎么买，到今天晚上你也得卖出去。有这些精力，去隔壁公园散散步不好？所以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">t=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的最优策略是不要买东西，输出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>。</p>
<p>不难发现，<strong>每天卖出纪念品换回的金币可以立即用于购买纪念品</strong>，当日购买的纪念品也可以当日卖出换回金币。</p>
<p>这意味着我们可以当天下午买入的纪念品，在第二天早上卖出，第二天下午买入，第三天早上卖出，第三天下午买入，第四天早上卖出，和从第一天下午买入，第四天上午卖出无任何区别。</p>
<p>所以我们只需要观察每天的行为即可。不难发现每天的行为是独立的。</p>
<p>也就是说，问题转换成了——</p>
<blockquote>
<p>现在有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>种物品，每种物品有无数个。你现在可以选择将这个物品塞进背包，获得<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">p_{i+1,k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的收益，代价是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">p_{i,k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>。其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>是第几天，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>是第几个物品，求<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>天结束后你的最大收益。</p>
</blockquote>
<p>那这是啥？完全背包啊！</p>
<p>那直接把完全背包板子套上去即可。</p>
<p>可惜考场上没写出来。</p>
<ol start="10">
<li>Luogu5682 次大值</li>
</ol>
<ul>
<li>代码思路</li>
</ul>
<p>如果只有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个数那不存在次大值，输出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>。</p>
<p>先排序再去重，然后<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mtext> </mtext><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><msub><mi>a</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">a_i\bmod a_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的次大值就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>max</mi><mo>⁡</mo><mo>(</mo><msub><mi>a</mi><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></msub><mo separator="true">,</mo><msub><mi>a</mi><mi>n</mi></msub><mtext> </mtext><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><msub><mi>a</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">\max(a_{n-2},a_n\bmod a_{n-1})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[最小环代码]]></title>
        <id>https://ebeo-yvnjiang.github.io/post/zui-xiao-huan-dai-ma/</id>
        <link href="https://ebeo-yvnjiang.github.io/post/zui-xiao-huan-dai-ma/">
        </link>
        <updated>2020-07-29T02:45:31.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define ns &quot;-1&quot;
#define fs(i,x,y,z) for(ll i=x;i&lt;=y;i+=z)
#define ft(i,x,y,z) for(ll i=x;i&gt;=y;i+=z)
#define ll long long
#define ull unsigned long long
#define db double
#define ms(a,b) memset(a,b,sizeof(a))
#define sz(a) sizeof(a)
using namespace std;
const int rw[]={-1,0,1,0,-1,1,-1,1},cl[]={0,1,0,-1,-1,1,1,-1};
const int N=1001,inf=1e8;
int n,m,a[N][N],f[N][N],ans=inf;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin&gt;&gt;n&gt;&gt;m;
	fs(i,1,n,1){
		fs(j,1,n,1){
			if(i-j){
				a[i][j]=f[i][j]=inf;
			}
		}
	}
	fs(i,1,m,1){
		int u,v,w;
		cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;
		a[u][v]=f[u][v]=w;
		a[v][u]=f[v][u]=w;
	}
	fs(k,1,n,1){
		fs(i,1,k-1,1){
			fs(j,i+1,k-1,1){
				if(ans&gt;f[i][j]+a[i][k]+a[k][j]){
					ans=f[i][j]+a[i][k]+a[k][j];
				}
			}
		}
		fs(i,1,n,1){
			fs(j,1,n,1){
				if(f[i][j]&gt;f[i][k]+f[k][j]){
					f[i][j]=f[i][k]+f[k][j];
				}
				f[j][i]=f[i][j];
			}
		}
	}
	if(ans&gt;=inf){
		cout&lt;&lt;&quot;No solution.&quot;;
	}else{
		cout&lt;&lt;ans;
	}
	return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[染色法判二分图]]></title>
        <id>https://ebeo-yvnjiang.github.io/post/ran-se-fa-pan-er-fen-tu/</id>
        <link href="https://ebeo-yvnjiang.github.io/post/ran-se-fa-pan-er-fen-tu/">
        </link>
        <updated>2020-07-23T12:34:52.000Z</updated>
        <content type="html"><![CDATA[<p>给出一张由<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个点，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>条边组成的无向图。</p>
<p>请你帮忙检查，是否有可能将这<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个点分成两个集合（集合<code>A</code>和集合<code>B</code>），使得这两个集合满足如下要求：</p>
<p>1.对于某个点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>，它要么在集合<code>A</code>中，要么在集合<code>B</code>中。并且不会同时在两个集合中。</p>
<p>2.对于某条边<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>，假设它连接的两个点分别为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>。要求点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>和点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>一个在<code>A</code>集合中，一个在<code>B</code>集合中。（即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>在集合<code>A</code>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>在集合<code>B</code>或<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>在集合<code>B</code>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>在集合<code>A</code>）。</p>
<p>满足的话输出<code>Yes</code>，否则输出<code>No</code>。</p>
<p>除此之外，二分图的点数是偶数，并且其所有回路的长度是偶数。</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define ns &quot;-1&quot;
#define fs(i,x,y,z) for(ll i=x;i&lt;=y;i+=z)
#define ft(i,x,y,z) for(ll i=x;i&gt;=y;i+=z)
#define ll long long
#define ull unsigned long long
#define db double
#define ms(a,b) memset(a,b,sizeof(a))
#define sz(a) sizeof(a)
using namespace std;
const int rw[]={-1,0,1,0,-1,1,-1,1},cl[]={0,1,0,-1,-1,1,1,-1};
const int N=100001,inf=0x3f3f3f3f;
const int daynum[]={114514,31,28,31,30,31,30,31,31,30,31,30,31};
const db E=2.718281828459,pi=acos(-1.0),eps=0.0000000001;
inline int read(){
	int date=0,w=1;char c=0;
	while(c&lt;'0'||c&gt;'9'){if(c=='-')w=-1;c=getchar();}
	while(c&gt;='0'&amp;&amp;c&lt;='9'){date=date*10+c-'0';c=getchar();}
	return date*w;
}
struct bian{
	int next,to,w;
	bian(){
        w=0;
		next=0;
	}
}e[N];
int n,m,head[N],totm,ans,color[N];
void add(int s,int ed,int rm=0){
	e[++totm].next=head[s];
	e[totm].to=ed;
    e[totm].w=rm;
	head[s]=totm;
}
bool dfs(int now){
	for(int i=head[now];i;i=e[i].next){
		int con=e[i].to;
		if(!color[con]){
			color[con]=1-color[now];
			if(!dfs(con)) return 0;
		}
		if(color[con]==color[now]) return 0;
	}
	return 1;
}
int main(){
	n=read(),m=read();
	fs(i,1,m,1){
		int u,v,w;
		u=read(),v=read();
		add(u,v);
		add(v,u);
	}
	totm--;
	if(dfs(1)) puts(&quot;Yes&quot;);
	else puts(&quot;No&quot;);
	return 0;
}
/*染色法。
我们给1号节点染上红色，而1的所有邻接点黑，那些邻接点的所有邻接点红……
红是A集合，黑是B几何。
如果有一个点既在A里边又在B里边，那么有问题，这玩意不是二分图。
如果完全没问题，那就OK。
*/
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线性筛代码]]></title>
        <id>https://ebeo-yvnjiang.github.io/post/xian-xing-shai-dai-ma/</id>
        <link href="https://ebeo-yvnjiang.github.io/post/xian-xing-shai-dai-ma/">
        </link>
        <updated>2020-07-23T01:47:30.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>关键在于：每个合数只被它最大的非自身的因数筛掉。</p>
</blockquote>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define ns &quot;-1&quot;
#define fs(i,x,y,z) for(ll i=x;i&lt;=y;i+=z)
#define ft(i,x,y,z) for(ll i=x;i&gt;=y;i+=z)
#define ll long long
#define ull unsigned long long
#define db double
#define ms(a,b) memset(a,b,sizeof(a))
#define sz(a) sizeof(a)
using namespace std;
const int rw[]={-1,0,1,0,-1,1,-1,1},cl[]={0,1,0,-1,-1,1,1,-1};
const int N=100000001,inf=0x3f3f3f3f;
const int daynum[]={114514,31,28,31,30,31,30,31,31,30,31,30,31};
const db E=2.718281828459,pi=acos(-1.0),eps=0.0000000001;
inline int read(){
	int date=0,w=1;char c=0;
	while(c&lt;'0'||c&gt;'9'){if(c=='-')w=-1;c=getchar();}
	while(c&gt;='0'&amp;&amp;c&lt;='9'){date=date*10+c-'0';c=getchar();}
	return date*w;
}
int n,q,prms[N],tot;
//1不是0是 
bool prm[N];
int main(){
	n=read(),q=read();
	prm[0]=prm[1]=1;
	fs(i,2,n,1){
		if(!prm[i]) prms[tot++]=i;
		for(ll j=0;j&lt;tot&amp;&amp;i*prms[j]&lt;=n;j++){
			prm[i*prms[j]]=1;
			if(i%prms[j]==0) break;//保证了每个数只会被筛一次
		}
	}
	while(q--){
		int p=read();
		printf(&quot;%d\n&quot;,prms[p-1]);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++高精度完整版]]></title>
        <id>https://ebeo-yvnjiang.github.io/post/cgao-jing-du-wan-zheng-ban/</id>
        <link href="https://ebeo-yvnjiang.github.io/post/cgao-jing-du-wan-zheng-ban/">
        </link>
        <updated>2020-07-21T04:39:37.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define ns &quot;-1&quot;
#define fs(i,x,y,z) for(ll i=x;i&lt;=y;i+=z)
#define ft(i,x,y,z) for(ll i=x;i&gt;=y;i+=z)
#define ll long long
#define ull unsigned long long
#define db double
#define ms(a,b) memset(a,b,sizeof(a))
#define sz(a) sizeof(a)
using namespace std;
const int rw[]={-1,0,1,0,-1,1,-1,1},cl[]={0,1,0,-1,-1,1,1,-1};
const int N=10001,inf=0x3f3f3f3f;
struct number{
	int len,num[N];
	bool isfu;
	number &amp; operator = (const char*);
	number &amp; operator = (int);
	number();
	number(int);
	bool operator &gt; (const number &amp;) const;
	bool operator &lt; (const number &amp;) const;
	bool operator &gt;= (const number &amp;) const;
	bool operator &lt;= (const number &amp;) const;
	bool operator != (const number &amp;) const;
	bool operator == (const number &amp;) const;
	number operator + (const number &amp;) const;
	number operator - (const number &amp;) const;
	number operator * (const number &amp;) const;
	number operator / (const number &amp;) const;
	number operator % (const number &amp;) const;
	number operator += (const number &amp;);
	number operator -= (const number &amp;);
	number operator *= (const number &amp;);
	number operator /= ( number &amp;);
	number operator %= ( number &amp;);
	number operator ++ ();
	number operator -- ();
};
void deletezero(number &amp;p){
	while(p.num[p.len]==0&amp;&amp;p.len&gt;1) p.len--;
	if(p.len==1&amp;&amp;p.num[1]==0&amp;&amp;p.isfu) p.isfu=0;
}
number abs(number p){
	number k=p;
	k.isfu=0;
	return k;	
}
number &amp; number::operator = (const char* c){
	ms(num,0);
	int n=strlen(c),j=1,k=1;
	if(c[0]=='-'){
		isfu=1;
		fs(i,2,n,1){
			if(k&gt;=10000){
				j++;
				k=1;
			} 
			num[j]+=k*(c[n-i+1]-'0');
			k*=10;
		}
		len=j;
		deletezero(*this);
		return *this;
	}
	fs(i,1,n,1){
		if(k&gt;=10000){
			j++;
			k=1;
		} 
		num[j]+=k*(c[n-i]-'0');
		k*=10;
	}
	len=j;
	deletezero(*this);
	return *this;
}
number &amp; number::operator = (int p){
	char s[N];
	sprintf(s,&quot;%d&quot;,p);
	return *this=s;
}
number::number(){
	ms(num,0);
	len=1;
	isfu=0;
}
number::number(int p){
	*this=p;
}
bool number::operator &gt; (const number &amp;b) const{
	if(isfu&amp;&amp;b.isfu==0) return 0;
	if(isfu==0&amp;&amp;b.isfu) return 1;
	bool w=!isfu;
	if(len!=b.len) return (len&gt;b.len)*w;
	ft(i,len,1,-1){
		if(num[i]!=b.num[i]) return (num[i]&gt;b.num[i])*w;
	}
	return 0;
}
bool number::operator &lt; (const number &amp;b) const{
	return b&gt;*this;
}
bool number::operator &lt;= (const number &amp;b) const{
	return !(*this&gt;b);
}
bool number::operator &gt;= (const number &amp;b) const{
	return !(b&gt;*this);
}
bool number::operator != (const number &amp;b) const{
	return (b&gt;*this)||(*this&gt;b);
}
bool number::operator == (const number &amp;b) const{
	return !(*this&gt;b)&amp;&amp;!(b&gt;*this);
}
ostream &amp; operator &lt;&lt; (ostream &amp;o,number p){
	if(p.isfu) o&lt;&lt;'-';
	o&lt;&lt;p.num[p.len];
	ft(i,p.len-1,1,-1){
		o.width(4);
		o.fill('0');
		o&lt;&lt;p.num[i];
	}
	return o;
}
istream &amp; operator &gt;&gt; (istream &amp;x,number &amp;p){
	char s[N];
	x&gt;&gt;s;
	p=s;
	return x;
}
number number::operator + (const number &amp;b) const{
	number c,a=*this;
	if(isfu&amp;&amp;b.isfu==0){
		//if(b&lt;abs(a)){
			number k=abs(a);
			if(b&gt;=k) c=b-k;
			else c=k-b;
			if(b&lt;abs(a)) c.isfu=1;
			deletezero(c);
			return c;
		//}
	}else if(isfu==0&amp;&amp;b.isfu){
		//if(a&lt;abs(b)){
			number k=abs(b);
			if(a&gt;=k) c=a-k;
			else c=k-a;
			if(a&lt;abs(b)) c.isfu=1;
			deletezero(c);
			return c;
		//}
	}
	c.len=max(len,b.len);
	fs(i,1,c.len,1){
		c.num[i]+=num[i]+b.num[i];
		if(c.num[i]&gt;=10000){
			c.num[i]-=10000;
			c.num[i+1]++;
		}
	}
	if(c.num[c.len+1]&gt;0) c.len++;
	deletezero(c);
	c.isfu=isfu;
	return c;
}
number number::operator - (const number &amp;b) const{
	number c,a=*this;
	if(isfu==0&amp;&amp;b.isfu==0&amp;&amp;a&lt;b){
		c=b-a;
		c.isfu=1;
		return c;
	}else if(isfu&amp;&amp;b.isfu==0){
		number k=abs(a);
		c=k+b;
		c.isfu=1;
		return c;
	}else if(isfu==0&amp;&amp;b.isfu){
		return a+abs(b);
	}else if(isfu&amp;&amp;b.isfu){
		c=abs(b)-abs(a);
		//c.isfu=1;
		return c;
	}
	c.len=len;
	fs(i,1,c.len,1){
		c.num[i]+=num[i]-b.num[i];
		if(c.num[i]&lt;0){
			c.num[i]+=10000;
			c.num[i+1]--;
		}
	}
	deletezero(c);
	return c;
}
number number::operator += (const number &amp;b) {
	return *this=*this+b;
}
number number::operator -= (const number &amp;b) {
	return *this=*this-b;
}
number number::operator ++ () {
	return *this=*this+1;
}
number number::operator -- () {
	return *this=*this-1;
}
number number::operator * (const number &amp;b) const{
	number c;
	if((isfu&amp;&amp;b.isfu==0)||(isfu==0&amp;&amp;b.isfu)) c.isfu=1;
	else c.isfu=0;
	c.len=len+b.len+1;
	fs(i,1,len,1){
		fs(j,1,b.len,1){
			c.num[i+j-1]+=num[i]*b.num[j];
			c.num[i+j]+=c.num[i+j-1]/10000;
			c.num[i+j-1]%=10000;
		}
		
	}
	deletezero(c);
	return c;
}
number number::operator *= (const number &amp;b) {
	return *this=(*this)*b;
}
number number::operator / (const number &amp;b) const{
	number c,d;
	if((isfu&amp;&amp;b.isfu==0)||(isfu==0&amp;&amp;b.isfu)) c.isfu=1;
	else c.isfu=0;
	c.len=len+b.len+1;d.len=0;
	ft(i,len,1,-1){
		memmove(d.num+2,d.num+1,sz(d.num)-sz(int)*2);
		d.len++;
		d.num[1]=num[i];
     int l=0,r=9999,m;
		while(l&lt;r){
			m=(l+r)/2;
			if((b*number(m))&lt;=d) l=m+1;
			else r=m;
		}
     c.num[i]=r-1;
     d=d-b*number(r-1);
	}
	deletezero(c);
	return c;
}
number number::operator /= ( number &amp;b) {
	return *this=(*this)/b;
}
number number::operator % (const number &amp;b) const{
	if(*this&lt;b) return *this;
	number c,d;if((isfu&amp;&amp;b.isfu==0)||(isfu==0&amp;&amp;b.isfu)) c.isfu=1;
	else c.isfu=0;
	d.isfu=isfu;
	c.len=len+b.len+1;d.len=0;
	ft(i,len,1,-1){
		memmove(d.num+2,d.num+1,sz(d.num)-sz(int)*2);
		d.len++;
		d.num[1]=num[i];
		int l=0,r=9999,m;
		while(l&lt;r){
			m=(l+r)/2;
			if((b*number(m))&lt;=d) l=m+1;
			else r=m;
		}
     c.num[i]=r-1;
     d=d-b*number(r-1);
     }
	deletezero(c);
	return d;
}
number number::operator %= ( number &amp;b) {
	return *this=(*this)%b;
}
number a,b;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin&gt;&gt;a&gt;&gt;b;
	cout&lt;&lt;a+b&lt;&lt;'\n'&lt;&lt;a-b&lt;&lt;'\n'&lt;&lt;a*b&lt;&lt;'\n'&lt;&lt;a/b&lt;&lt;'\n'&lt;&lt;a%b;
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[欧拉路径&哈密尔顿路径]]></title>
        <id>https://ebeo-yvnjiang.github.io/post/ou-la-lu-jing-andha-mi-er-dun-lu-jing/</id>
        <link href="https://ebeo-yvnjiang.github.io/post/ou-la-lu-jing-andha-mi-er-dun-lu-jing/">
        </link>
        <updated>2020-07-19T09:26:00.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>
<p>啥是这俩东西？</p>
<ol>
<li>欧拉路径 指 把图上所有边都走一遍的路径。</li>
</ol>
<ul>
<li>如果一个回路是欧拉路径，则称为欧拉回路。</li>
</ul>
<ol start="2">
<li>哈密尔顿路径 指 把图上所有点都走一遍的路径。</li>
</ol>
<ul>
<li>如果一个回路是哈密尔顿路径，则称为哈密尔顿回路。</li>
</ul>
</li>
<li>
<p>已知一个无向图，怎么样这两种路径才会存在？</p>
</li>
</ol>
<ul>
<li>如果有<strong>最多两个度数是奇数的点</strong>，那么这个图存在欧拉路径，起点是一个度数是奇数的点，终点也是。</li>
<li>如果这个图没有度数是奇数的点，那么这个图存在欧拉回路（也就是环），那么它的起点就是终点。</li>
<li>如果有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>点，并且每个点的度数都<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≥</mo><mrow><mo fence="true">{</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mi>n</mi><mn>2</mn></mfrac></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>n</mi><mtext> </mtext><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mn>2</mn><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></mfrac></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>n</mi><mtext> </mtext><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mn>2</mn><mo>=</mo><mn>1</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\ge \begin{cases}\frac n2&amp;n\bmod 2=0\\\frac{n+1}2&amp;n\bmod2=1\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，那么存在哈密尔顿回路。</li>
</ul>
<ol start="3">
<li>求的方法</li>
</ol>
<p>DFS。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[拓补排序]]></title>
        <id>https://ebeo-yvnjiang.github.io/post/tuo-bu-pai-xu/</id>
        <link href="https://ebeo-yvnjiang.github.io/post/tuo-bu-pai-xu/">
        </link>
        <updated>2020-07-19T09:20:38.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>
<p>理解难度</p>
<p>我觉得挺好理解的。</p>
</li>
<li>
<p>用途</p>
<p>求有向无环图的拓补序列。</p>
</li>
<li>
<p>具体操作</p>
<ul>
<li>将入度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>的全部进队，放到答案序列里</li>
<li>队列不空？</li>
<li>取队头元素遍历，遍历到的点入度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span></li>
<li>如果这些点现在入度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>了就进队，放到答案序列里</li>
</ul>
</li>
<li>
<p>代码</p>
</li>
</ol>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define ns &quot;-1&quot;
#define fs(i,x,y,z) for(ll i=x;i&lt;=y;i+=z)
#define ft(i,x,y,z) for(ll i=x;i&gt;=y;i+=z)
#define ll long long
#define ull unsigned long long
#define db double
#define ms(a,b) memset(a,b,sizeof(a))
#define sz(a) sizeof(a)
using namespace std;
const int rw[]={-1,0,1,0,-1,1,-1,1},cl[]={0,1,0,-1,-1,1,1,-1};
const int N=200001,inf=0x3f3f3f3f;
const int daynum[]={114514,31,28,31,30,31,30,31,31,30,31,30,31};
const db E=2.718281828459,pi=acos(-1.0),eps=0.0000000001;
inline int read(){
	int date=0,w=1;char c=0;
	while(c&lt;'0'||c&gt;'9'){if(c=='-')w=-1;c=getchar();}
	while(c&gt;='0'&amp;&amp;c&lt;='9'){date=date*10+c-'0';c=getchar();}
	return date*w;
}
int n,r[N],m,head[N],totm;
int tot,ans[N];
queue&lt;int&gt; q;
struct bian{
	int next,to,w;
	bian(){
        w=0;
		next=0;
	}
}e[N];
void add(int s,int ed,int rm=0){
	e[++totm].next=head[s];
	e[totm].to=ed;
    e[totm].w=rm;
	head[s]=totm;
}
int main(){
	n=read(),m=read();
	fs(i,1,m,1){
		int u=read(),v=read();
		add(u,v);
		r[v]++;
	}
	fs(i,1,n,1){
		if(!r[i]){
			q.push(i);
			ans[++tot]=i;
		}
	}
	while(!q.empty()){
		int now=q.front();
		q.pop();
		for(int i=head[now];i;i=e[i].next){
			int v=e[i].to;
			r[v]--;
			if(!r[v]){
				q.push(v);
				ans[++tot]=v;
			}
		}
	}
	if(tot&lt;n){
		puts(&quot;-1&quot;);//有环 
		return 0;
	}
	fs(i,1,n,1) printf(&quot;%d &quot;,ans[i]);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浅谈两种nim游戏]]></title>
        <id>https://ebeo-yvnjiang.github.io/post/qian-tan-biao-zhun-nim-you-xi/</id>
        <link href="https://ebeo-yvnjiang.github.io/post/qian-tan-biao-zhun-nim-you-xi/">
        </link>
        <updated>2020-07-18T14:24:25.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>
<p>啥是标准nim游戏？</p>
<p><strong>题目来源洛谷</strong></p>
<p>有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>堆石子，每堆有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>个石子。</p>
<p>每人每次可以在一堆石子中取一些石子扔掉，，可以取完，不能不取。每次只能从一堆里取。</p>
<p>最后没石子可取的人就输了。假如甲是先手，且告诉你这<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>堆石子的数量，他想知道是否存在先手必胜的策略。</p>
<p>这个策略就是nim游戏。</p>
</li>
<li>
<p>nim游戏怎么做到先手必败？</p>
</li>
</ol>
<p>若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>⊕</mo><msub><mi>a</mi><mn>2</mn></msub><mo>⊕</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>a</mi><mi>n</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a_1\oplus a_2\oplus ...a_n=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，那么甲输。</p>
<p>否则乙输。</p>
<ol start="3">
<li>
<p>代码？（多组数据）</p>
<p>时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>t</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(tn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<pre><code class="language-cpp"> #include&lt;bits/stdc++.h&gt;
 #define ns &quot;-1&quot;
 #define fs(i,x,y,z) for(ll i=x;i&lt;=y;i+=z)
 #define ft(i,x,y,z) for(ll i=x;i&gt;=y;i+=z)
 #define ll long long
 #define ull unsigned long long
 #define db double
 #define ms(a,b) memset(a,b,sizeof(a))
 #define sz(a) sizeof(a)
 using namespace std;
 const int rw[]={-1,0,1,0,-1,1,-1,1},cl[]={0,1,0,-1,-1,1,1,-1};
 const int N=100001,inf=0x7f7f7f7f;
 int n,a,m,jk;
 int main(){
     ios::sync_with_stdio(false);
     cin.tie(0);
     cout.tie(0);
     cin&gt;&gt;n;
     fs(i,1,n,1){
         cin&gt;&gt;m;jk=0;
         fs(i,1,m,1){
             cin&gt;&gt;a;
             jk^=a;
         }
         if(jk==0) cout&lt;&lt;&quot;No\n&quot;;
         else cout&lt;&lt;&quot;Yes\n&quot;;
     }
     return 0;
 }

</code></pre>
</li>
<li>
<p>第一种扩展nim游戏</p>
</li>
</ol>
<p><strong>来源AcWing</strong></p>
<p>现在，有一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>级台阶的楼梯，每级台阶上都有若干个石子，其中第i级台阶上有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>个石子(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i\ge 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>)。</p>
<p>两位玩家轮流操作，每次操作可以从任意一级台阶上拿若干个石子放到下一级台阶中（不能不拿）。</p>
<p>已经拿到地面上的石子不能再拿，最后无法进行操作的人视为失败。</p>
<p>问如果两人都采用最优策略，先手是否必胜。</p>
<ol start="5">
<li>第一种扩展题解</li>
</ol>
<p>如果如果先手时奇数台阶上的值的异或值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，则先手必败，反之必胜。</p>
<p>也就是说，若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>是奇数，那么若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>⊕</mo><msub><mi>a</mi><mn>3</mn></msub><mo>⊕</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>a</mi><mi>n</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a_1\oplus a_3\oplus ...a_n=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，那么甲输。</p>
<p>否则若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>⊕</mo><msub><mi>a</mi><mn>3</mn></msub><mo>⊕</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>a</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a_1\oplus a_3\oplus ...a_{n-1}=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，那么甲输。</p>
<ol start="6">
<li>
<p>代码</p>
<pre><code class="language-cpp"> #include &lt;iostream&gt;
 using namespace std;
 int res,a,n;
 int main(){
     cin&gt;&gt;n;
     for(int i=1;i&lt;=n;i++){
         cin&gt;&gt;a;
         if(i&amp;1) res^=a;
     }
     if(!res) puts(&quot;No&quot;);
     else puts(&quot;Yes&quot;);
     return 0;
 }//AcWing上有时间限制提交，所以代码比较丑
</code></pre>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[KMP算法]]></title>
        <id>https://ebeo-yvnjiang.github.io/post/kmp-suan-fa/</id>
        <link href="https://ebeo-yvnjiang.github.io/post/kmp-suan-fa/">
        </link>
        <updated>2020-06-27T12:01:20.000Z</updated>
        <content type="html"><![CDATA[<p>懒得讲了，直接背吧（</p>
<p>用途：求字符串<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>是否在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>中出现过。</p>
<p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>s</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><mi>p</mi><mi mathvariant="normal">∣</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(|s|+|p|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault">s</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault">p</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span>。</p>
<p>Ps：我们这里字符串下标从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>开始计数。</p>
<p>大致思路：</p>
<p>如果是BF算法，那么失配了就算了（</p>
<p>但是如果是KMP算法的话，那么失配了就要跳到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">f_{j-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>上（代码称为<code>fail</code>）。</p>
<p>如果发现一个字符失配了，那么我们就要把<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>移到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>中与失配字符相同的那一位，比如<code>114514</code>和<code>1919810</code>就要移到将<code>114514</code>的第一个<code>1</code>和<code>1919810</code>的第二个<code>1</code>重合。</p>
<p>而这个怎么移呢？答案就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span>数组！</p>
<p>那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span>数组怎么求呢？很简单，我们直接定义<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是在<strong>第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>位以前的离<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>最近的并且和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">p_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>相同的字符的位置</strong>。</p>
<p>具体证明略（</p>
<p>然后就放个代码吧qwq</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define ns &quot;-1&quot;
#define fs(i,x,y,z) for(ll i=x;i&lt;=y;i+=z)
#define ft(i,x,y,z) for(ll i=x;i&gt;=y;i+=z)
#define ll long long
#define ull unsigned long long
#define db double
#define ms(a,b) memset(a,b,sizeof(a))
#define sz(a) sizeof(a)
using namespace std;
const int rw[]={-1,0,1,0,-1,1,-1,1},cl[]={0,1,0,-1,-1,1,1,-1};
const int N=1000001,inf=0x3f3f3f3f;
inline int read(){
	int date=0,w=1;char c=0;
	while(c&lt;'0'||c&gt;'9'){if(c=='-')w=-1;c=getchar();}
	while(c&gt;='0'&amp;&amp;c&lt;='9'){date=date*10+c-'0';c=getchar();}
	return date*w;
}
string s,p;
int m,n,sa,fail[N];
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin&gt;&gt;s&gt;&gt;p;m=s.size(),n=p.size();
	int j=0;
	fs(i,1,n-1,1){
		while(j&gt;0&amp;&amp;p[i]!=p[j]) j=fail[j-1];
		if(p[i]==p[j]) j++;
		fail[i]=j;	
	}
	j=0;
	fs(i,0,m-1,1){
		while(j&gt;0&amp;&amp;s[i]!=p[j]) j=fail[j-1];
		if(s[i]==p[j]) j++;
		if(j==n){
			cout&lt;&lt;i-n+2&lt;&lt;'\n';
			//j=fail[j];
			j=fail[j-1];
		}	
	}
	fs(i,0,n-1,1) cout&lt;&lt;fail[i]&lt;&lt;' ';
	return 0;
}

</code></pre>
<p>Ps：这是洛谷模板的代码。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Trie]]></title>
        <id>https://ebeo-yvnjiang.github.io/post/trie/</id>
        <link href="https://ebeo-yvnjiang.github.io/post/trie/">
        </link>
        <updated>2020-06-20T09:34:10.000Z</updated>
        <content type="html"><![CDATA[<p>占坑。</p>
<p>填坑。</p>
<h2 id="1-trie是什么">1. Trie是什么</h2>
<p>Trie树又名字典树，是一种多叉树，常应用于关键词屏蔽等方面。</p>
<h2 id="2-trie树的构造">2. Trie树的构造</h2>
<ol>
<li>
<p>每个节点都有的：</p>
<ul>
<li>一个自然数<code>bih</code>表示自己是几号节点 <s>，但通常可以忽略</s>。</li>
<li>一个整数/字符<code>id</code>表示自己存的是什么，我习惯用整数存，并且用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>表示啥都没存。</li>
<li>一个数组<code>con</code>，<code>con[i]</code>表示自己的子节点中有没有ASCII码是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>的节点，如果没有就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，有的话就是那个节点的<code>bih</code>。</li>
<li>一个<code>bool</code>值<code>end</code>表示是否有单词在这个节点结尾，如在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>{</mo><mn>114</mn><mo separator="true">,</mo><mn>114514</mn><mo>}</mo></mrow><annotation encoding="application/x-tex">\{114,114514\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">1</span><span class="mord">1</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">4</span><span class="mord">5</span><span class="mord">1</span><span class="mord">4</span><span class="mclose">}</span></span></span></span>中，第一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">end</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span>就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</li>
</ul>
</li>
<li>
<p>就根节点有的：</p>
<ul>
<li>对于根节点，我们不存<code>con</code>除外的任何信息，只用一种方法表示<code>这是根节点</code>即可。</li>
<li>通常方法是直接把根节点的<code>bih</code>设成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。</li>
</ul>
</li>
<li>
<p>节点的初始化：</p>
<ul>
<li>首先<code>con</code>肯定要全设成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，因为现在还没有字符串，那么自然就不存在节点的链接，所以每一个点的<code>con</code>都全是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。</li>
<li>然后<code>end</code>也要设成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，原因同上。</li>
<li>接下来<code>id</code>要设成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>，原因同上。</li>
</ul>
</li>
</ol>
<p>这些节点全部存在<code>a</code>数组里，数组的最大大小<code>N=100001</code>。</p>
<h2 id="3-节点的统计">3. 节点的统计</h2>
<p>Problem：给<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个字符串，做一棵Trie树，求Trie树的节点总数。</p>
<p>Solution：</p>
<p>对于每一个字符串<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，输入后循环遍历这个字符串。</p>
<p>当我们在字符串开头时，我们目前在的节点<code>now=0</code>，<strong>但是我们已经到第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>位了，已经有字符了</strong>，所以我们要看看有没有连接到字符串<strong>这一位</strong>的边。</p>
<p>如果有的话，那么就跳过去；</p>
<p>如果没有的话，那么就 <strong><code>ans++</code>，并且新建一个节点</strong>，其中<code>bih=ans</code>，也就是当前<strong>不含根的</strong>节点总数；而<code>id</code>就是当前字符串的第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>位。</p>
<p>接下来，再<strong>从<code>now</code>节点连一条边</strong>到这个<code>bih</code>是<code>ans</code>的节点。</p>
<p>连边的代码就是<code>a[now].con[k[i]]=ans;</code></p>
<p><strong>接下来还要跳过去</strong>，也就是<code>now=ans;</code></p>
<p>接下来到第二位。</p>
<p>当我们在字符串第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>位时，我们目前在的节点<code>now=ans</code>，<strong>但是我们已经到第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>位了，已经不是第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>位的字符了</strong>，所以我们要看看有没有连接到字符串<strong>这一位</strong>的边。</p>
<p>如果有的话，那么就跳过去；</p>
<p>如果没有的话，那么就 <strong><code>ans++</code>，并且新建一个节点</strong>，其中<code>bih=ans</code>，也就是当前<strong>不含根的</strong>节点总数；而<code>id</code>就是当前字符串的第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>位。</p>
<p>接下来，再<strong>从<code>now</code>节点连一条边</strong>到这个<code>bih</code>是<code>ans</code>的节点。</p>
<p>连边的代码就是<code>a[now].con[k[i]]=ans;</code></p>
<p><strong>接下来还要跳过去</strong>，也就是<code>now=ans;</code></p>
<p>然后就这样跳下去，直到最后一位……</p>
<p>当我们在字符串第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>k</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|k|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">∣</span></span></span></span>位时，我们目前在的节点<code>now=ans</code>，<strong>但是我们已经到第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>k</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|k|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">∣</span></span></span></span>位了，已经不是第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>k</mi><mi mathvariant="normal">∣</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">|k|-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>位的字符了</strong>，所以我们要看看有没有连接到字符串<strong>这一位</strong>的边。</p>
<p>如果有的话，那么就跳过去；</p>
<p>如果没有的话，那么就 <strong><code>ans++</code>，并且新建一个节点</strong>，其中<code>bih=ans</code>，也就是当前<strong>不含根的</strong>节点总数；而<code>id</code>就是当前字符串的第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>k</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|k|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">∣</span></span></span></span>位。</p>
<p>接下来，再<strong>从<code>now</code>节点连一条边</strong>到这个<code>bih</code>是<code>ans</code>的节点。</p>
<p>连边的代码就是<code>a[now].con[k[i]]=ans;</code></p>
<p><strong>接下来还要跳过去</strong>，也就是<code>now=ans;</code></p>
<p>好了，跳到了。</p>
<p>但是，这意味着，这个字符串已经走到了行程的终点。</p>
<p>既然到了终点，那么就得做个标记，也就是<code>a[now].end=1</code>，表示从根节点到<code>now</code>，是一个信息。<s>比如在七号节点上边做一个<code>end</code>标记就可能意味着<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1919810</mn></mrow><annotation encoding="application/x-tex">1919810</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">9</span><span class="mord">1</span><span class="mord">9</span><span class="mord">8</span><span class="mord">1</span><span class="mord">0</span></span></span></span>是个很臭的数字（bushi</s></p>
<p>done.</p>
<p>一个一个字符串读入完， <strong><code>ans+1</code>（包括根节点也要算进去）</strong> 就是最终的答案。</p>
<p>附：洛谷P2580代码</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define ns &quot;-1&quot;
#define fs(i,x,y,z) for(ll i=x;i&lt;=y;i+=z)
#define ft(i,x,y,z) for(ll i=x;i&gt;=y;i+=z)
#define ll long long
#define ull unsigned long long
#define db double
#define ms(a,b) memset(a,b,sizeof(a))
#define sz(a) sizeof(a)
using namespace std;
const int rw[]={-1,0,1,0,-1,1,-1,1},cl[]={0,1,0,-1,-1,1,1,-1};
const int N=10001,inf=0x3f3f3f3f;
const int daynum[]={114514,31,28,31,30,31,30,31,31,30,31,30,31};
const db E=2.718281828459,pi=acos(-1.0),eps=0.0000000001;
inline int read(){
	int date=0,w=1;char c=0;
	while(c&lt;'0'||c&gt;'9'){if(c=='-')w=-1;c=getchar();}
	while(c&gt;='0'&amp;&amp;c&lt;='9'){date=date*10+c-'0';c=getchar();}
	return date*w;
}
struct point{
	int end;
	int id,con[27];
	point(){
		id=-1;
		ms(con,0);
		end=0;
	}
}a[N*51];
char z[N][51],k[51],q[51];
int m,w,ans=1,pp;
void dfs(int now){
	fs(i,60,127,1) if(a[now].con[i]){
		printf(&quot;%d-&gt;(%c&quot;,now,i);
		printf(&quot; %d)\n&quot;,a[now].con[i]);
		system(&quot;pause&quot;);
		dfs(a[now].con[i]);
	}
	printf(&quot;886 from %d\n&quot;,now);
	if(a[now].end) printf(&quot;%d is end!\n&quot;,now);
}
int main(){
	pp=read();
	while(cin&gt;&gt;z[++w]){
		if(w&gt;=pp) break;
	}
	fs(lzl,1,w,1){
		strcpy(k,z[lzl]);
		int now=1,l=strlen(k)-1;
		for(ll i=0;k[i];i++){
			if(a[now].con[k[i]-'a']){
				now=a[now].con[k[i]-'a'];
				if(i==l) a[now].end=1;
			}else{
				ans++;
				a[ans].id=k[i]-'a';
				a[now].con[k[i]-'a']=ans;
				now=ans;
				if(i==l) a[now].end=1;
			}
		}
	}
	m=read();
	ans=1;
	
	fs(lzl,1,m,1){
		cin&gt;&gt;k;bool f=0;
		int now=1,l=strlen(k)-1;
		for(ll i=0;k[i];i++){
			//printf(&quot;%d\n&quot;,now);
			if(a[now].con[k[i]-'a']){
				now=a[now].con[k[i]-'a'];
				//printf(&quot;%d\nqwq\n&quot;,now);
			}else{
				puts(&quot;WRONG&quot;);
				f=1;
				break;
			} 
		}
		if(a[now].end==1&amp;&amp;!f){
			a[now].end=2;
			puts(&quot;OK&quot;);
		}else if(a[now].end==0&amp;&amp;!f){
			puts(&quot;WRONG&quot;);
		}else if(!f){
			puts(&quot;REPEAT&quot;);
		}
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>
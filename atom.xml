<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ebeo-yvnjiang.github.io</id>
    <title>Billy2007&amp;GoneTimeの世界</title>
    <updated>2020-08-10T13:40:19.467Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ebeo-yvnjiang.github.io"/>
    <link rel="self" href="https://ebeo-yvnjiang.github.io/atom.xml"/>
    <subtitle>萧索，飘摇。</subtitle>
    <logo>https://ebeo-yvnjiang.github.io/images/avatar.png</logo>
    <icon>https://ebeo-yvnjiang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Billy2007&amp;GoneTimeの世界</rights>
    <entry>
        <title type="html"><![CDATA[最小环代码]]></title>
        <id>https://ebeo-yvnjiang.github.io/post/zui-xiao-huan-dai-ma/</id>
        <link href="https://ebeo-yvnjiang.github.io/post/zui-xiao-huan-dai-ma/">
        </link>
        <updated>2020-07-29T02:45:31.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define ns &quot;-1&quot;
#define fs(i,x,y,z) for(ll i=x;i&lt;=y;i+=z)
#define ft(i,x,y,z) for(ll i=x;i&gt;=y;i+=z)
#define ll long long
#define ull unsigned long long
#define db double
#define ms(a,b) memset(a,b,sizeof(a))
#define sz(a) sizeof(a)
using namespace std;
const int rw[]={-1,0,1,0,-1,1,-1,1},cl[]={0,1,0,-1,-1,1,1,-1};
const int N=1001,inf=1e8;
int n,m,a[N][N],f[N][N],ans=inf;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin&gt;&gt;n&gt;&gt;m;
	fs(i,1,n,1){
		fs(j,1,n,1){
			if(i-j){
				a[i][j]=f[i][j]=inf;
			}
		}
	}
	fs(i,1,m,1){
		int u,v,w;
		cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;
		a[u][v]=f[u][v]=w;
		a[v][u]=f[v][u]=w;
	}
	fs(k,1,n,1){
		fs(i,1,k-1,1){
			fs(j,i+1,k-1,1){
				if(ans&gt;f[i][j]+a[i][k]+a[k][j]){
					ans=f[i][j]+a[i][k]+a[k][j];
				}
			}
		}
		fs(i,1,n,1){
			fs(j,1,n,1){
				if(f[i][j]&gt;f[i][k]+f[k][j]){
					f[i][j]=f[i][k]+f[k][j];
				}
				f[j][i]=f[i][j];
			}
		}
	}
	if(ans&gt;=inf){
		cout&lt;&lt;&quot;No solution.&quot;;
	}else{
		cout&lt;&lt;ans;
	}
	return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[染色法判二分图]]></title>
        <id>https://ebeo-yvnjiang.github.io/post/ran-se-fa-pan-er-fen-tu/</id>
        <link href="https://ebeo-yvnjiang.github.io/post/ran-se-fa-pan-er-fen-tu/">
        </link>
        <updated>2020-07-23T12:34:52.000Z</updated>
        <content type="html"><![CDATA[<p>给出一张由<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个点，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>条边组成的无向图。</p>
<p>请你帮忙检查，是否有可能将这<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个点分成两个集合（集合<code>A</code>和集合<code>B</code>），使得这两个集合满足如下要求：</p>
<p>1.对于某个点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>，它要么在集合<code>A</code>中，要么在集合<code>B</code>中。并且不会同时在两个集合中。</p>
<p>2.对于某条边<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>，假设它连接的两个点分别为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>。要求点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>和点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>一个在<code>A</code>集合中，一个在<code>B</code>集合中。（即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>在集合<code>A</code>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>在集合<code>B</code>或<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>在集合<code>B</code>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>在集合<code>A</code>）。</p>
<p>满足的话输出<code>Yes</code>，否则输出<code>No</code>。</p>
<p>除此之外，二分图的点数是偶数，并且其所有回路的长度是偶数。</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define ns &quot;-1&quot;
#define fs(i,x,y,z) for(ll i=x;i&lt;=y;i+=z)
#define ft(i,x,y,z) for(ll i=x;i&gt;=y;i+=z)
#define ll long long
#define ull unsigned long long
#define db double
#define ms(a,b) memset(a,b,sizeof(a))
#define sz(a) sizeof(a)
using namespace std;
const int rw[]={-1,0,1,0,-1,1,-1,1},cl[]={0,1,0,-1,-1,1,1,-1};
const int N=100001,inf=0x3f3f3f3f;
const int daynum[]={114514,31,28,31,30,31,30,31,31,30,31,30,31};
const db E=2.718281828459,pi=acos(-1.0),eps=0.0000000001;
inline int read(){
	int date=0,w=1;char c=0;
	while(c&lt;'0'||c&gt;'9'){if(c=='-')w=-1;c=getchar();}
	while(c&gt;='0'&amp;&amp;c&lt;='9'){date=date*10+c-'0';c=getchar();}
	return date*w;
}
struct bian{
	int next,to,w;
	bian(){
        w=0;
		next=0;
	}
}e[N];
int n,m,head[N],totm,ans,color[N];
void add(int s,int ed,int rm=0){
	e[++totm].next=head[s];
	e[totm].to=ed;
    e[totm].w=rm;
	head[s]=totm;
}
bool dfs(int now){
	for(int i=head[now];i;i=e[i].next){
		int con=e[i].to;
		if(!color[con]){
			color[con]=1-color[now];
			if(!dfs(con)) return 0;
		}
		if(color[con]==color[now]) return 0;
	}
	return 1;
}
int main(){
	n=read(),m=read();
	fs(i,1,m,1){
		int u,v,w;
		u=read(),v=read();
		add(u,v);
		add(v,u);
	}
	totm--;
	if(dfs(1)) puts(&quot;Yes&quot;);
	else puts(&quot;No&quot;);
	return 0;
}
/*染色法。
我们给1号节点染上红色，而1的所有邻接点黑，那些邻接点的所有邻接点红……
红是A集合，黑是B几何。
如果有一个点既在A里边又在B里边，那么有问题，这玩意不是二分图。
如果完全没问题，那就OK。
*/
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线性筛代码]]></title>
        <id>https://ebeo-yvnjiang.github.io/post/xian-xing-shai-dai-ma/</id>
        <link href="https://ebeo-yvnjiang.github.io/post/xian-xing-shai-dai-ma/">
        </link>
        <updated>2020-07-23T01:47:30.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>关键在于：每个合数只被它最大的非自身的因数筛掉。</p>
</blockquote>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define ns &quot;-1&quot;
#define fs(i,x,y,z) for(ll i=x;i&lt;=y;i+=z)
#define ft(i,x,y,z) for(ll i=x;i&gt;=y;i+=z)
#define ll long long
#define ull unsigned long long
#define db double
#define ms(a,b) memset(a,b,sizeof(a))
#define sz(a) sizeof(a)
using namespace std;
const int rw[]={-1,0,1,0,-1,1,-1,1},cl[]={0,1,0,-1,-1,1,1,-1};
const int N=100000001,inf=0x3f3f3f3f;
const int daynum[]={114514,31,28,31,30,31,30,31,31,30,31,30,31};
const db E=2.718281828459,pi=acos(-1.0),eps=0.0000000001;
inline int read(){
	int date=0,w=1;char c=0;
	while(c&lt;'0'||c&gt;'9'){if(c=='-')w=-1;c=getchar();}
	while(c&gt;='0'&amp;&amp;c&lt;='9'){date=date*10+c-'0';c=getchar();}
	return date*w;
}
int n,q,prms[N],tot;
//1不是0是 
bool prm[N];
int main(){
	n=read(),q=read();
	prm[0]=prm[1]=1;
	fs(i,2,n,1){
		if(!prm[i]) prms[tot++]=i;
		for(ll j=0;j&lt;tot&amp;&amp;i*prms[j]&lt;=n;j++){
			prm[i*prms[j]]=1;
			if(i%prms[j]==0) break;//保证了每个数只会被筛一次
		}
	}
	while(q--){
		int p=read();
		printf(&quot;%d\n&quot;,prms[p-1]);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++高精度完整版]]></title>
        <id>https://ebeo-yvnjiang.github.io/post/cgao-jing-du-wan-zheng-ban/</id>
        <link href="https://ebeo-yvnjiang.github.io/post/cgao-jing-du-wan-zheng-ban/">
        </link>
        <updated>2020-07-21T04:39:37.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define ns &quot;-1&quot;
#define fs(i,x,y,z) for(ll i=x;i&lt;=y;i+=z)
#define ft(i,x,y,z) for(ll i=x;i&gt;=y;i+=z)
#define ll long long
#define ull unsigned long long
#define db double
#define ms(a,b) memset(a,b,sizeof(a))
#define sz(a) sizeof(a)
using namespace std;
const int rw[]={-1,0,1,0,-1,1,-1,1},cl[]={0,1,0,-1,-1,1,1,-1};
const int N=10001,inf=0x3f3f3f3f;
struct number{
	int len,num[N];
	bool isfu;
	number &amp; operator = (const char*);
	number &amp; operator = (int);
	number();
	number(int);
	bool operator &gt; (const number &amp;) const;
	bool operator &lt; (const number &amp;) const;
	bool operator &gt;= (const number &amp;) const;
	bool operator &lt;= (const number &amp;) const;
	bool operator != (const number &amp;) const;
	bool operator == (const number &amp;) const;
	number operator + (const number &amp;) const;
	number operator - (const number &amp;) const;
	number operator * (const number &amp;) const;
	number operator / (const number &amp;) const;
	number operator % (const number &amp;) const;
	number operator += (const number &amp;);
	number operator -= (const number &amp;);
	number operator *= (const number &amp;);
	number operator /= ( number &amp;);
	number operator %= ( number &amp;);
	number operator ++ ();
	number operator -- ();
};
void deletezero(number &amp;p){
	while(p.num[p.len]==0&amp;&amp;p.len&gt;1) p.len--;
	if(p.len==1&amp;&amp;p.num[1]==0&amp;&amp;p.isfu) p.isfu=0;
}
number abs(number p){
	number k=p;
	k.isfu=0;
	return k;	
}
number &amp; number::operator = (const char* c){
	ms(num,0);
	int n=strlen(c),j=1,k=1;
	if(c[0]=='-'){
		isfu=1;
		fs(i,2,n,1){
			if(k&gt;=10000){
				j++;
				k=1;
			} 
			num[j]+=k*(c[n-i+1]-'0');
			k*=10;
		}
		len=j;
		deletezero(*this);
		return *this;
	}
	fs(i,1,n,1){
		if(k&gt;=10000){
			j++;
			k=1;
		} 
		num[j]+=k*(c[n-i]-'0');
		k*=10;
	}
	len=j;
	deletezero(*this);
	return *this;
}
number &amp; number::operator = (int p){
	char s[N];
	sprintf(s,&quot;%d&quot;,p);
	return *this=s;
}
number::number(){
	ms(num,0);
	len=1;
	isfu=0;
}
number::number(int p){
	*this=p;
}
bool number::operator &gt; (const number &amp;b) const{
	if(isfu&amp;&amp;b.isfu==0) return 0;
	if(isfu==0&amp;&amp;b.isfu) return 1;
	bool w=!isfu;
	if(len!=b.len) return (len&gt;b.len)*w;
	ft(i,len,1,-1){
		if(num[i]!=b.num[i]) return (num[i]&gt;b.num[i])*w;
	}
	return 0;
}
bool number::operator &lt; (const number &amp;b) const{
	return b&gt;*this;
}
bool number::operator &lt;= (const number &amp;b) const{
	return !(*this&gt;b);
}
bool number::operator &gt;= (const number &amp;b) const{
	return !(b&gt;*this);
}
bool number::operator != (const number &amp;b) const{
	return (b&gt;*this)||(*this&gt;b);
}
bool number::operator == (const number &amp;b) const{
	return !(*this&gt;b)&amp;&amp;!(b&gt;*this);
}
ostream &amp; operator &lt;&lt; (ostream &amp;o,number p){
	if(p.isfu) o&lt;&lt;'-';
	o&lt;&lt;p.num[p.len];
	ft(i,p.len-1,1,-1){
		o.width(4);
		o.fill('0');
		o&lt;&lt;p.num[i];
	}
	return o;
}
istream &amp; operator &gt;&gt; (istream &amp;x,number &amp;p){
	char s[N];
	x&gt;&gt;s;
	p=s;
	return x;
}
number number::operator + (const number &amp;b) const{
	number c,a=*this;
	if(isfu&amp;&amp;b.isfu==0){
		//if(b&lt;abs(a)){
			number k=abs(a);
			if(b&gt;=k) c=b-k;
			else c=k-b;
			if(b&lt;abs(a)) c.isfu=1;
			deletezero(c);
			return c;
		//}
	}else if(isfu==0&amp;&amp;b.isfu){
		//if(a&lt;abs(b)){
			number k=abs(b);
			if(a&gt;=k) c=a-k;
			else c=k-a;
			if(a&lt;abs(b)) c.isfu=1;
			deletezero(c);
			return c;
		//}
	}
	c.len=max(len,b.len);
	fs(i,1,c.len,1){
		c.num[i]+=num[i]+b.num[i];
		if(c.num[i]&gt;=10000){
			c.num[i]-=10000;
			c.num[i+1]++;
		}
	}
	if(c.num[c.len+1]&gt;0) c.len++;
	deletezero(c);
	c.isfu=isfu;
	return c;
}
number number::operator - (const number &amp;b) const{
	number c,a=*this;
	if(isfu==0&amp;&amp;b.isfu==0&amp;&amp;a&lt;b){
		c=b-a;
		c.isfu=1;
		return c;
	}else if(isfu&amp;&amp;b.isfu==0){
		number k=abs(a);
		c=k+b;
		c.isfu=1;
		return c;
	}else if(isfu==0&amp;&amp;b.isfu){
		return a+abs(b);
	}else if(isfu&amp;&amp;b.isfu){
		c=abs(b)-abs(a);
		//c.isfu=1;
		return c;
	}
	c.len=len;
	fs(i,1,c.len,1){
		c.num[i]+=num[i]-b.num[i];
		if(c.num[i]&lt;0){
			c.num[i]+=10000;
			c.num[i+1]--;
		}
	}
	deletezero(c);
	return c;
}
number number::operator += (const number &amp;b) {
	return *this=*this+b;
}
number number::operator -= (const number &amp;b) {
	return *this=*this-b;
}
number number::operator ++ () {
	return *this=*this+1;
}
number number::operator -- () {
	return *this=*this-1;
}
number number::operator * (const number &amp;b) const{
	number c;
	if((isfu&amp;&amp;b.isfu==0)||(isfu==0&amp;&amp;b.isfu)) c.isfu=1;
	else c.isfu=0;
	c.len=len+b.len+1;
	fs(i,1,len,1){
		fs(j,1,b.len,1){
			c.num[i+j-1]+=num[i]*b.num[j];
			c.num[i+j]+=c.num[i+j-1]/10000;
			c.num[i+j-1]%=10000;
		}
		
	}
	deletezero(c);
	return c;
}
number number::operator *= (const number &amp;b) {
	return *this=(*this)*b;
}
number number::operator / (const number &amp;b) const{
	number c,d;
	if((isfu&amp;&amp;b.isfu==0)||(isfu==0&amp;&amp;b.isfu)) c.isfu=1;
	else c.isfu=0;
	c.len=len+b.len+1;d.len=0;
	ft(i,len,1,-1){
		memmove(d.num+2,d.num+1,sz(d.num)-sz(int)*2);
		d.len++;
		d.num[1]=num[i];
     int l=0,r=9999,m;
		while(l&lt;r){
			m=(l+r)/2;
			if((b*number(m))&lt;=d) l=m+1;
			else r=m;
		}
     c.num[i]=r-1;
     d=d-b*number(r-1);
	}
	deletezero(c);
	return c;
}
number number::operator /= ( number &amp;b) {
	return *this=(*this)/b;
}
number number::operator % (const number &amp;b) const{
	if(*this&lt;b) return *this;
	number c,d;if((isfu&amp;&amp;b.isfu==0)||(isfu==0&amp;&amp;b.isfu)) c.isfu=1;
	else c.isfu=0;
	d.isfu=isfu;
	c.len=len+b.len+1;d.len=0;
	ft(i,len,1,-1){
		memmove(d.num+2,d.num+1,sz(d.num)-sz(int)*2);
		d.len++;
		d.num[1]=num[i];
		int l=0,r=9999,m;
		while(l&lt;r){
			m=(l+r)/2;
			if((b*number(m))&lt;=d) l=m+1;
			else r=m;
		}
     c.num[i]=r-1;
     d=d-b*number(r-1);
     }
	deletezero(c);
	return d;
}
number number::operator %= ( number &amp;b) {
	return *this=(*this)%b;
}
number a,b;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin&gt;&gt;a&gt;&gt;b;
	cout&lt;&lt;a+b&lt;&lt;'\n'&lt;&lt;a-b&lt;&lt;'\n'&lt;&lt;a*b&lt;&lt;'\n'&lt;&lt;a/b&lt;&lt;'\n'&lt;&lt;a%b;
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[欧拉路径&哈密尔顿路径]]></title>
        <id>https://ebeo-yvnjiang.github.io/post/ou-la-lu-jing-andha-mi-er-dun-lu-jing/</id>
        <link href="https://ebeo-yvnjiang.github.io/post/ou-la-lu-jing-andha-mi-er-dun-lu-jing/">
        </link>
        <updated>2020-07-19T09:26:00.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>
<p>啥是这俩东西？</p>
<ol>
<li>欧拉路径 指 把图上所有边都走一遍的路径。</li>
</ol>
<ul>
<li>如果一个回路是欧拉路径，则称为欧拉回路。</li>
</ul>
<ol start="2">
<li>哈密尔顿路径 指 把图上所有点都走一遍的路径。</li>
</ol>
<ul>
<li>如果一个回路是哈密尔顿路径，则称为哈密尔顿回路。</li>
</ul>
</li>
<li>
<p>已知一个无向图，怎么样这两种路径才会存在？</p>
</li>
</ol>
<ul>
<li>如果有<strong>最多两个度数是奇数的点</strong>，那么这个图存在欧拉路径，起点是一个度数是奇数的点，终点也是。</li>
<li>如果这个图没有度数是奇数的点，那么这个图存在欧拉回路（也就是环），那么它的起点就是终点。</li>
<li>如果有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>点，并且每个点的度数都<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≥</mo><mrow><mo fence="true">{</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mi>n</mi><mn>2</mn></mfrac></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>n</mi><mtext> </mtext><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mn>2</mn><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></mfrac></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>n</mi><mtext> </mtext><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mn>2</mn><mo>=</mo><mn>1</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\ge \begin{cases}\frac n2&amp;n\bmod 2=0\\\frac{n+1}2&amp;n\bmod2=1\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，那么存在哈密尔顿回路。</li>
</ul>
<ol start="3">
<li>求的方法</li>
</ol>
<p>DFS。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[拓补排序]]></title>
        <id>https://ebeo-yvnjiang.github.io/post/tuo-bu-pai-xu/</id>
        <link href="https://ebeo-yvnjiang.github.io/post/tuo-bu-pai-xu/">
        </link>
        <updated>2020-07-19T09:20:38.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>
<p>理解难度</p>
<p>我觉得挺好理解的。</p>
</li>
<li>
<p>用途</p>
<p>求有向无环图的拓补序列。</p>
</li>
<li>
<p>具体操作</p>
<ul>
<li>将入度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>的全部进队，放到答案序列里</li>
<li>队列不空？</li>
<li>取队头元素遍历，遍历到的点入度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span></li>
<li>如果这些点现在入度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>了就进队，放到答案序列里</li>
</ul>
</li>
<li>
<p>代码</p>
</li>
</ol>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define ns &quot;-1&quot;
#define fs(i,x,y,z) for(ll i=x;i&lt;=y;i+=z)
#define ft(i,x,y,z) for(ll i=x;i&gt;=y;i+=z)
#define ll long long
#define ull unsigned long long
#define db double
#define ms(a,b) memset(a,b,sizeof(a))
#define sz(a) sizeof(a)
using namespace std;
const int rw[]={-1,0,1,0,-1,1,-1,1},cl[]={0,1,0,-1,-1,1,1,-1};
const int N=200001,inf=0x3f3f3f3f;
const int daynum[]={114514,31,28,31,30,31,30,31,31,30,31,30,31};
const db E=2.718281828459,pi=acos(-1.0),eps=0.0000000001;
inline int read(){
	int date=0,w=1;char c=0;
	while(c&lt;'0'||c&gt;'9'){if(c=='-')w=-1;c=getchar();}
	while(c&gt;='0'&amp;&amp;c&lt;='9'){date=date*10+c-'0';c=getchar();}
	return date*w;
}
int n,r[N],m,head[N],totm;
int tot,ans[N];
queue&lt;int&gt; q;
struct bian{
	int next,to,w;
	bian(){
        w=0;
		next=0;
	}
}e[N];
void add(int s,int ed,int rm=0){
	e[++totm].next=head[s];
	e[totm].to=ed;
    e[totm].w=rm;
	head[s]=totm;
}
int main(){
	n=read(),m=read();
	fs(i,1,m,1){
		int u=read(),v=read();
		add(u,v);
		r[v]++;
	}
	fs(i,1,n,1){
		if(!r[i]){
			q.push(i);
			ans[++tot]=i;
		}
	}
	while(!q.empty()){
		int now=q.front();
		q.pop();
		for(int i=head[now];i;i=e[i].next){
			int v=e[i].to;
			r[v]--;
			if(!r[v]){
				q.push(v);
				ans[++tot]=v;
			}
		}
	}
	if(tot&lt;n){
		puts(&quot;-1&quot;);//有环 
		return 0;
	}
	fs(i,1,n,1) printf(&quot;%d &quot;,ans[i]);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浅谈两种nim游戏]]></title>
        <id>https://ebeo-yvnjiang.github.io/post/qian-tan-biao-zhun-nim-you-xi/</id>
        <link href="https://ebeo-yvnjiang.github.io/post/qian-tan-biao-zhun-nim-you-xi/">
        </link>
        <updated>2020-07-18T14:24:25.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>
<p>啥是标准nim游戏？</p>
<p><strong>题目来源洛谷</strong></p>
<p>有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>堆石子，每堆有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>个石子。</p>
<p>每人每次可以在一堆石子中取一些石子扔掉，，可以取完，不能不取。每次只能从一堆里取。</p>
<p>最后没石子可取的人就输了。假如甲是先手，且告诉你这<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>堆石子的数量，他想知道是否存在先手必胜的策略。</p>
<p>这个策略就是nim游戏。</p>
</li>
<li>
<p>nim游戏怎么做到先手必败？</p>
</li>
</ol>
<p>若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>⊕</mo><msub><mi>a</mi><mn>2</mn></msub><mo>⊕</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>a</mi><mi>n</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a_1\oplus a_2\oplus ...a_n=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，那么甲输。</p>
<p>否则乙输。</p>
<ol start="3">
<li>
<p>代码？（多组数据）</p>
<p>时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>t</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(tn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<pre><code class="language-cpp"> #include&lt;bits/stdc++.h&gt;
 #define ns &quot;-1&quot;
 #define fs(i,x,y,z) for(ll i=x;i&lt;=y;i+=z)
 #define ft(i,x,y,z) for(ll i=x;i&gt;=y;i+=z)
 #define ll long long
 #define ull unsigned long long
 #define db double
 #define ms(a,b) memset(a,b,sizeof(a))
 #define sz(a) sizeof(a)
 using namespace std;
 const int rw[]={-1,0,1,0,-1,1,-1,1},cl[]={0,1,0,-1,-1,1,1,-1};
 const int N=100001,inf=0x7f7f7f7f;
 int n,a,m,jk;
 int main(){
     ios::sync_with_stdio(false);
     cin.tie(0);
     cout.tie(0);
     cin&gt;&gt;n;
     fs(i,1,n,1){
         cin&gt;&gt;m;jk=0;
         fs(i,1,m,1){
             cin&gt;&gt;a;
             jk^=a;
         }
         if(jk==0) cout&lt;&lt;&quot;No\n&quot;;
         else cout&lt;&lt;&quot;Yes\n&quot;;
     }
     return 0;
 }

</code></pre>
</li>
<li>
<p>第一种扩展nim游戏</p>
</li>
</ol>
<p><strong>来源AcWing</strong></p>
<p>现在，有一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>级台阶的楼梯，每级台阶上都有若干个石子，其中第i级台阶上有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>个石子(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i\ge 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>)。</p>
<p>两位玩家轮流操作，每次操作可以从任意一级台阶上拿若干个石子放到下一级台阶中（不能不拿）。</p>
<p>已经拿到地面上的石子不能再拿，最后无法进行操作的人视为失败。</p>
<p>问如果两人都采用最优策略，先手是否必胜。</p>
<ol start="5">
<li>第一种扩展题解</li>
</ol>
<p>如果如果先手时奇数台阶上的值的异或值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，则先手必败，反之必胜。</p>
<p>也就是说，若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>是奇数，那么若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>⊕</mo><msub><mi>a</mi><mn>3</mn></msub><mo>⊕</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>a</mi><mi>n</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a_1\oplus a_3\oplus ...a_n=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，那么甲输。</p>
<p>否则若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>⊕</mo><msub><mi>a</mi><mn>3</mn></msub><mo>⊕</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>a</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a_1\oplus a_3\oplus ...a_{n-1}=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，那么甲输。</p>
<ol start="6">
<li>
<p>代码</p>
<pre><code class="language-cpp"> #include &lt;iostream&gt;
 using namespace std;
 int res,a,n;
 int main(){
     cin&gt;&gt;n;
     for(int i=1;i&lt;=n;i++){
         cin&gt;&gt;a;
         if(i&amp;1) res^=a;
     }
     if(!res) puts(&quot;No&quot;);
     else puts(&quot;Yes&quot;);
     return 0;
 }//AcWing上有时间限制提交，所以代码比较丑
</code></pre>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[KMP算法]]></title>
        <id>https://ebeo-yvnjiang.github.io/post/kmp-suan-fa/</id>
        <link href="https://ebeo-yvnjiang.github.io/post/kmp-suan-fa/">
        </link>
        <updated>2020-06-27T12:01:20.000Z</updated>
        <content type="html"><![CDATA[<p>懒得讲了，直接背吧（</p>
<p>用途：求字符串<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>是否在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>中出现过。</p>
<p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>s</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><mi>p</mi><mi mathvariant="normal">∣</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(|s|+|p|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault">s</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault">p</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span>。</p>
<p>Ps：我们这里字符串下标从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>开始计数。</p>
<p>大致思路：</p>
<p>如果是BF算法，那么失配了就算了（</p>
<p>但是如果是KMP算法的话，那么失配了就要跳到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">f_{j-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>上（代码称为<code>fail</code>）。</p>
<p>如果发现一个字符失配了，那么我们就要把<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>移到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>中与失配字符相同的那一位，比如<code>114514</code>和<code>1919810</code>就要移到将<code>114514</code>的第一个<code>1</code>和<code>1919810</code>的第二个<code>1</code>重合。</p>
<p>而这个怎么移呢？答案就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span>数组！</p>
<p>那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span>数组怎么求呢？很简单，我们直接定义<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是在<strong>第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>位以前的离<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>最近的并且和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">p_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>相同的字符的位置</strong>。</p>
<p>具体证明略（</p>
<p>然后就放个代码吧qwq</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define ns &quot;-1&quot;
#define fs(i,x,y,z) for(ll i=x;i&lt;=y;i+=z)
#define ft(i,x,y,z) for(ll i=x;i&gt;=y;i+=z)
#define ll long long
#define ull unsigned long long
#define db double
#define ms(a,b) memset(a,b,sizeof(a))
#define sz(a) sizeof(a)
using namespace std;
const int rw[]={-1,0,1,0,-1,1,-1,1},cl[]={0,1,0,-1,-1,1,1,-1};
const int N=1000001,inf=0x3f3f3f3f;
inline int read(){
	int date=0,w=1;char c=0;
	while(c&lt;'0'||c&gt;'9'){if(c=='-')w=-1;c=getchar();}
	while(c&gt;='0'&amp;&amp;c&lt;='9'){date=date*10+c-'0';c=getchar();}
	return date*w;
}
string s,p;
int m,n,sa,fail[N];
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin&gt;&gt;s&gt;&gt;p;m=s.size(),n=p.size();
	int j=0;
	fs(i,1,n-1,1){
		while(j&gt;0&amp;&amp;p[i]!=p[j]) j=fail[j-1];
		if(p[i]==p[j]) j++;
		fail[i]=j;	
	}
	j=0;
	fs(i,0,m-1,1){
		while(j&gt;0&amp;&amp;s[i]!=p[j]) j=fail[j-1];
		if(s[i]==p[j]) j++;
		if(j==n){
			cout&lt;&lt;i-n+2&lt;&lt;'\n';
			//j=fail[j];
			j=fail[j-1];
		}	
	}
	fs(i,0,n-1,1) cout&lt;&lt;fail[i]&lt;&lt;' ';
	return 0;
}

</code></pre>
<p>Ps：这是洛谷模板的代码。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Trie]]></title>
        <id>https://ebeo-yvnjiang.github.io/post/trie/</id>
        <link href="https://ebeo-yvnjiang.github.io/post/trie/">
        </link>
        <updated>2020-06-20T09:34:10.000Z</updated>
        <content type="html"><![CDATA[<p>占坑。</p>
<p>填坑。</p>
<h2 id="1-trie是什么">1. Trie是什么</h2>
<p>Trie树又名字典树，是一种多叉树，常应用于关键词屏蔽等方面。</p>
<h2 id="2-trie树的构造">2. Trie树的构造</h2>
<ol>
<li>
<p>每个节点都有的：</p>
<ul>
<li>一个自然数<code>bih</code>表示自己是几号节点 <s>，但通常可以忽略</s>。</li>
<li>一个整数/字符<code>id</code>表示自己存的是什么，我习惯用整数存，并且用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>表示啥都没存。</li>
<li>一个数组<code>con</code>，<code>con[i]</code>表示自己的子节点中有没有ASCII码是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>的节点，如果没有就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，有的话就是那个节点的<code>bih</code>。</li>
<li>一个<code>bool</code>值<code>end</code>表示是否有单词在这个节点结尾，如在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>{</mo><mn>114</mn><mo separator="true">,</mo><mn>114514</mn><mo>}</mo></mrow><annotation encoding="application/x-tex">\{114,114514\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">1</span><span class="mord">1</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">4</span><span class="mord">5</span><span class="mord">1</span><span class="mord">4</span><span class="mclose">}</span></span></span></span>中，第一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">end</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span>就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</li>
</ul>
</li>
<li>
<p>就根节点有的：</p>
<ul>
<li>对于根节点，我们不存<code>con</code>除外的任何信息，只用一种方法表示<code>这是根节点</code>即可。</li>
<li>通常方法是直接把根节点的<code>bih</code>设成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。</li>
</ul>
</li>
<li>
<p>节点的初始化：</p>
<ul>
<li>首先<code>con</code>肯定要全设成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，因为现在还没有字符串，那么自然就不存在节点的链接，所以每一个点的<code>con</code>都全是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。</li>
<li>然后<code>end</code>也要设成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，原因同上。</li>
<li>接下来<code>id</code>要设成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>，原因同上。</li>
</ul>
</li>
</ol>
<p>这些节点全部存在<code>a</code>数组里，数组的最大大小<code>N=100001</code>。</p>
<h2 id="3-节点的统计">3. 节点的统计</h2>
<p>Problem：给<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个字符串，做一棵Trie树，求Trie树的节点总数。</p>
<p>Solution：</p>
<p>对于每一个字符串<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，输入后循环遍历这个字符串。</p>
<p>当我们在字符串开头时，我们目前在的节点<code>now=0</code>，<strong>但是我们已经到第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>位了，已经有字符了</strong>，所以我们要看看有没有连接到字符串<strong>这一位</strong>的边。</p>
<p>如果有的话，那么就跳过去；</p>
<p>如果没有的话，那么就 <strong><code>ans++</code>，并且新建一个节点</strong>，其中<code>bih=ans</code>，也就是当前<strong>不含根的</strong>节点总数；而<code>id</code>就是当前字符串的第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>位。</p>
<p>接下来，再<strong>从<code>now</code>节点连一条边</strong>到这个<code>bih</code>是<code>ans</code>的节点。</p>
<p>连边的代码就是<code>a[now].con[k[i]]=ans;</code></p>
<p><strong>接下来还要跳过去</strong>，也就是<code>now=ans;</code></p>
<p>接下来到第二位。</p>
<p>当我们在字符串第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>位时，我们目前在的节点<code>now=ans</code>，<strong>但是我们已经到第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>位了，已经不是第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>位的字符了</strong>，所以我们要看看有没有连接到字符串<strong>这一位</strong>的边。</p>
<p>如果有的话，那么就跳过去；</p>
<p>如果没有的话，那么就 <strong><code>ans++</code>，并且新建一个节点</strong>，其中<code>bih=ans</code>，也就是当前<strong>不含根的</strong>节点总数；而<code>id</code>就是当前字符串的第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>位。</p>
<p>接下来，再<strong>从<code>now</code>节点连一条边</strong>到这个<code>bih</code>是<code>ans</code>的节点。</p>
<p>连边的代码就是<code>a[now].con[k[i]]=ans;</code></p>
<p><strong>接下来还要跳过去</strong>，也就是<code>now=ans;</code></p>
<p>然后就这样跳下去，直到最后一位……</p>
<p>当我们在字符串第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>k</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|k|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">∣</span></span></span></span>位时，我们目前在的节点<code>now=ans</code>，<strong>但是我们已经到第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>k</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|k|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">∣</span></span></span></span>位了，已经不是第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>k</mi><mi mathvariant="normal">∣</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">|k|-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>位的字符了</strong>，所以我们要看看有没有连接到字符串<strong>这一位</strong>的边。</p>
<p>如果有的话，那么就跳过去；</p>
<p>如果没有的话，那么就 <strong><code>ans++</code>，并且新建一个节点</strong>，其中<code>bih=ans</code>，也就是当前<strong>不含根的</strong>节点总数；而<code>id</code>就是当前字符串的第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>k</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|k|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">∣</span></span></span></span>位。</p>
<p>接下来，再<strong>从<code>now</code>节点连一条边</strong>到这个<code>bih</code>是<code>ans</code>的节点。</p>
<p>连边的代码就是<code>a[now].con[k[i]]=ans;</code></p>
<p><strong>接下来还要跳过去</strong>，也就是<code>now=ans;</code></p>
<p>好了，跳到了。</p>
<p>但是，这意味着，这个字符串已经走到了行程的终点。</p>
<p>既然到了终点，那么就得做个标记，也就是<code>a[now].end=1</code>，表示从根节点到<code>now</code>，是一个信息。<s>比如在七号节点上边做一个<code>end</code>标记就可能意味着<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1919810</mn></mrow><annotation encoding="application/x-tex">1919810</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">9</span><span class="mord">1</span><span class="mord">9</span><span class="mord">8</span><span class="mord">1</span><span class="mord">0</span></span></span></span>是个很臭的数字（bushi</s></p>
<p>done.</p>
<p>一个一个字符串读入完， <strong><code>ans+1</code>（包括根节点也要算进去）</strong> 就是最终的答案。</p>
<p>附：洛谷P2580代码</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define ns &quot;-1&quot;
#define fs(i,x,y,z) for(ll i=x;i&lt;=y;i+=z)
#define ft(i,x,y,z) for(ll i=x;i&gt;=y;i+=z)
#define ll long long
#define ull unsigned long long
#define db double
#define ms(a,b) memset(a,b,sizeof(a))
#define sz(a) sizeof(a)
using namespace std;
const int rw[]={-1,0,1,0,-1,1,-1,1},cl[]={0,1,0,-1,-1,1,1,-1};
const int N=10001,inf=0x3f3f3f3f;
const int daynum[]={114514,31,28,31,30,31,30,31,31,30,31,30,31};
const db E=2.718281828459,pi=acos(-1.0),eps=0.0000000001;
inline int read(){
	int date=0,w=1;char c=0;
	while(c&lt;'0'||c&gt;'9'){if(c=='-')w=-1;c=getchar();}
	while(c&gt;='0'&amp;&amp;c&lt;='9'){date=date*10+c-'0';c=getchar();}
	return date*w;
}
struct point{
	int end;
	int id,con[27];
	point(){
		id=-1;
		ms(con,0);
		end=0;
	}
}a[N*51];
char z[N][51],k[51],q[51];
int m,w,ans=1,pp;
void dfs(int now){
	fs(i,60,127,1) if(a[now].con[i]){
		printf(&quot;%d-&gt;(%c&quot;,now,i);
		printf(&quot; %d)\n&quot;,a[now].con[i]);
		system(&quot;pause&quot;);
		dfs(a[now].con[i]);
	}
	printf(&quot;886 from %d\n&quot;,now);
	if(a[now].end) printf(&quot;%d is end!\n&quot;,now);
}
int main(){
	pp=read();
	while(cin&gt;&gt;z[++w]){
		if(w&gt;=pp) break;
	}
	fs(lzl,1,w,1){
		strcpy(k,z[lzl]);
		int now=1,l=strlen(k)-1;
		for(ll i=0;k[i];i++){
			if(a[now].con[k[i]-'a']){
				now=a[now].con[k[i]-'a'];
				if(i==l) a[now].end=1;
			}else{
				ans++;
				a[ans].id=k[i]-'a';
				a[now].con[k[i]-'a']=ans;
				now=ans;
				if(i==l) a[now].end=1;
			}
		}
	}
	m=read();
	ans=1;
	
	fs(lzl,1,m,1){
		cin&gt;&gt;k;bool f=0;
		int now=1,l=strlen(k)-1;
		for(ll i=0;k[i];i++){
			//printf(&quot;%d\n&quot;,now);
			if(a[now].con[k[i]-'a']){
				now=a[now].con[k[i]-'a'];
				//printf(&quot;%d\nqwq\n&quot;,now);
			}else{
				puts(&quot;WRONG&quot;);
				f=1;
				break;
			} 
		}
		if(a[now].end==1&amp;&amp;!f){
			a[now].end=2;
			puts(&quot;OK&quot;);
		}else if(a[now].end==0&amp;&amp;!f){
			puts(&quot;WRONG&quot;);
		}else if(!f){
			puts(&quot;REPEAT&quot;);
		}
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[尺规作图]]></title>
        <id>https://ebeo-yvnjiang.github.io/post/chi-gui-zuo-tu/</id>
        <link href="https://ebeo-yvnjiang.github.io/post/chi-gui-zuo-tu/">
        </link>
        <updated>2020-06-13T11:40:47.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-尺规作图的工具">1. 尺规作图的工具</h2>
<p><strong>无刻度</strong>的直尺以及圆规。</p>
<h2 id="2-本文的一些定义">2. 本文的一些定义</h2>
<p>物体：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mtext> </mtext><mi>A</mi><mtext> </mtext><mi>B</mi></mrow><annotation encoding="application/x-tex">L\ A\ B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mspace"> </span><span class="mord mathdefault">A</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>：线段<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">AB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mtext> </mtext><mi>l</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">L\ l1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord">1</span></span></span></span>：线段<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">l1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord">1</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mtext> </mtext><mi>A</mi><mtext> </mtext><mi>B</mi></mrow><annotation encoding="application/x-tex">X\ A\ B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace"> </span><span class="mord mathdefault">A</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>：射线<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">AB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mtext> </mtext><mi>l</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">X\ l1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord">1</span></span></span></span>：射线<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">l1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord">1</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi><mtext> </mtext><mi>A</mi><mi>O</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">K\ AOB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace"> </span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∠</mi><mi>A</mi><mi>O</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">∠AOB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69224em;vertical-align:0em;"></span><span class="mord">∠</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mtext> </mtext><mi>A</mi><mtext> </mtext><mi>B</mi></mrow><annotation encoding="application/x-tex">N\ A\ B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace"> </span><span class="mord mathdefault">A</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>：过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo separator="true">,</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A,B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>的直线</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mtext> </mtext><mi>l</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">N\ l1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord">1</span></span></span></span>：直线<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">l1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord">1</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mtext> </mtext><mi>O</mi><mtext> </mtext><mi>x</mi></mrow><annotation encoding="application/x-tex">R\ O\ x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mspace"> </span><span class="mord mathdefault">x</span></span></span></span>：以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span></span></span></span>为圆心，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>为半径的弧</li>
</ul>
<p>操作：</p>
<ul>
<li><code>make a</code>：画一个物体</li>
<li><code>con a b X</code>：定义物体<code>a</code>和<code>b</code>的交点为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span></li>
<li><code>qed a</code>：<code>a</code>即为所求</li>
<li><code>write a</code>：求线段<code>a</code>的长度或弧<code>a</code>的半径</li>
</ul>
<p>（Ps：很可能两个弧有两个及以上交点。。。那么这里就不写了，大家自己感性理解吧qwq/kel）</p>
<h2 id="3-常规做法">3. 常规做法：</h2>
<ol>
<li>
<p>求<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mtext> </mtext><mi>A</mi><mtext> </mtext><mi>C</mi><mo>=</mo><mi>L</mi><mtext> </mtext><mi>M</mi><mtext> </mtext><mi>N</mi></mrow><annotation encoding="application/x-tex">L\ A\ C=L\ M\ N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mspace"> </span><span class="mord mathdefault">A</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mtext> </mtext><mi>M</mi><mtext> </mtext><mi>N</mi></mrow><annotation encoding="application/x-tex">L\ M\ N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>已知）</p>
<p><code>make X A B</code></p>
<p><code>l=write(L M N)</code></p>
<p><code>make R A l</code></p>
<p><code>con(R A l) (X A B) C</code></p>
<p><code>qed (L A C)</code></p>
</li>
<li>
<p>求<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi><mtext> </mtext><mi>P</mi><mi>Q</mi><mi>R</mi><mo>=</mo><mi>K</mi><mtext> </mtext><mi>A</mi><mi>O</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">K\ PQR=K\ AOB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">Q</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace"> </span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> （<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi><mtext> </mtext><mi>A</mi><mi>O</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">K\ AOB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace"> </span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>已知）</p>
<p><code>make R O l</code></p>
<p><code>con(R O l)(X O B) C</code></p>
<p><code>con(R O l)(X O A) D</code></p>
<p><code>make X Q P</code></p>
<p><code>l=write(L O C)</code></p>
<p><code>make R Q l</code></p>
<p><code>con(R Q l)(X Q P) M</code></p>
<p><code>l=write(L C D)</code></p>
<p><code>make R M l</code></p>
<p><code>con(R Q l)(R M l) N</code></p>
<p><code>qed K NQP</code></p>
</li>
<li>
<p>求<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mtext> </mtext><mi>C</mi><mtext> </mtext><mi>D</mi></mrow><annotation encoding="application/x-tex">L\ C\ D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span>垂直于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mtext> </mtext><mi>A</mi><mtext> </mtext><mi>B</mi></mrow><annotation encoding="application/x-tex">L\ A\ B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mspace"> </span><span class="mord mathdefault">A</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>并且平分<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mtext> </mtext><mi>A</mi><mtext> </mtext><mi>B</mi></mrow><annotation encoding="application/x-tex">L\ A\ B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mspace"> </span><span class="mord mathdefault">A</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mtext> </mtext><mi>A</mi><mtext> </mtext><mi>B</mi></mrow><annotation encoding="application/x-tex">L\ A\ B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mspace"> </span><span class="mord mathdefault">A</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>已知）</p>
<pre><code>l=write(L A B)
make R A l
make R B l
con(R A l)(R B l) C
con(R A l)(R B l) D
qed L C D
</code></pre>
</li>
<li>
<p>求<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mtext> </mtext><mi>O</mi><mtext> </mtext><mi>C</mi></mrow><annotation encoding="application/x-tex">X\ O\ C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span>平分<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi><mtext> </mtext><mi>A</mi><mi>O</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">K\ AOB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace"> </span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi><mtext> </mtext><mi>A</mi><mi>O</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">K\ AOB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace"> </span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>已知）</p>
<pre><code>make R O l
con(R O l)(X O A) D
con(R O l)(X O B) E
make R D l
make R E l
con(R D l)(R E l) C
qed X O C
</code></pre>
</li>
<li>
<p>求过点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mtext> </mtext><mi>A</mi><mtext> </mtext><mi>B</mi></mrow><annotation encoding="application/x-tex">L\ A\ B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mspace"> </span><span class="mord mathdefault">A</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>，和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mtext> </mtext><mi>M</mi><mtext> </mtext><mi>N</mi></mrow><annotation encoding="application/x-tex">L\ M\ N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>垂直（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mtext> </mtext><mi>M</mi><mtext> </mtext><mi>N</mi></mrow><annotation encoding="application/x-tex">L\ M\ N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>已知）</p>
<pre><code>make R X l
con(R X l)(L M N) C
con(R X l)(L M N) D
make R C l
make R D l
con(R C l)(R D l) A
con(R C l)(R D l) B
qed L A B
</code></pre>
</li>
</ol>
]]></content>
    </entry>
</feed>